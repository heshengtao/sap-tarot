<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>AI 塔罗牌占卜</title>
<link rel="stylesheet" href="../../fontawesome/css/all.min.css">
<link rel="stylesheet" href="github-markdown-dark.css"/>
<script src="marked.min.js"></script>
<script src="lang/zh.js"></script>
<script src="lang/en.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Cormorant+Garamond:ital,wght@0,400;0,600;1,400&family=Lato:wght@300;400;700&display=swap" rel="stylesheet">
<style>
/* --- 1. 核心变量 --- */
:root {
  --bg-deep: #0b0f19;
  --bg-gradient-1: rgba(76, 201, 240, 0.12);
  --bg-gradient-2: rgba(157, 78, 221, 0.15);
  
  --glass-bg: rgba(20, 22, 35, 0.8); /* 稍微加深背景增加文字对比度 */
  --glass-border: rgba(255, 255, 255, 0.08);
  
  --gold-primary: #ffd700;
  --gold-dim: #c5a059;
  --accent-purple: #9d4edd;
  
  --text-primary: #f0f0f5;
  --text-secondary: #b0b0c0;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

/* --- 2. 全局背景与排版 --- */
body {
  font-family: 'Lato', -apple-system, BlinkMacSystemFont, sans-serif;
  background-color: var(--bg-deep);
  background-image: 
    radial-gradient(circle at 20% 30%, var(--bg-gradient-1) 0%, transparent 40%),
    radial-gradient(circle at 80% 70%, var(--bg-gradient-2) 0%, transparent 40%),
    radial-gradient(circle at 50% 50%, rgba(0,0,0,0) 0%, rgba(0,0,0,0.6) 100%);
  background-attachment: fixed;
  color: var(--text-primary);
  min-height: 100vh;
  overflow-x: hidden;
}

/* 噪点纹理 */
body::before {
  content: ""; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.04'/%3E%3C/svg%3E");
  pointer-events: none; z-index: -1;
}

.container {
  max-width: 1200px; margin: 0 auto; padding: 20px; position: relative; z-index: 1;
}

/* 语言切换 */
.language-toggle {
  position: fixed; top: 20px; right: 20px; z-index: 2000;
  display: flex; gap: 5px;
  background: rgba(15, 15, 25, 0.8);
  border: 1px solid var(--glass-border);
  border-radius: 30px; padding: 6px;
  backdrop-filter: blur(10px);
}
.lang-btn {
  padding: 6px 16px; border: none; border-radius: 20px;
  background: transparent; color: var(--text-secondary);
  font-family: 'Cinzel', serif; font-size: 0.85rem; cursor: pointer; transition: all 0.3s;
}
.lang-btn.active { background: var(--gold-dim); color: #000; }

/* 头部 */
.header { text-align: center; padding: 40px 0; }
.header h1 {
  font-family: 'Cinzel', serif; font-size: 3rem;
  background: linear-gradient(to bottom, #fff, #ffd700);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  text-shadow: 0 0 20px rgba(255, 215, 0, 0.3); margin-bottom: 10px;
}
.header p { font-family: 'Cormorant Garamond', serif; font-size: 1.3rem; color: var(--text-secondary); font-style: italic; }

/* 面板通用 */
.question-section, .interpretation {
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  border-radius: 20px; padding: 40px;
  backdrop-filter: blur(12px);
  box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
  margin-bottom: 40px; text-align: center;
}

.question-section h2 { font-family: 'Cinzel', serif; color: var(--gold-dim); margin-bottom: 20px; }
.question-input {
  width: 100%; max-width: 600px; padding: 18px 25px; font-size: 1.1rem;
  background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 215, 0, 0.2);
  border-radius: 50px; color: #fff; margin-bottom: 30px; outline: none; transition: border 0.3s;
}
.question-input:focus { border-color: var(--gold-primary); box-shadow: 0 0 15px rgba(255, 215, 0, 0.1); }

/* 按钮 */
.start-btn, .reset-btn {
  background: linear-gradient(135deg, #4b2c7a, #a14e6b);
  border: none; padding: 14px 40px; border-radius: 50px;
  color: white; font-family: 'Cinzel', serif; font-size: 1.1rem;
  cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;
  box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}
.start-btn:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(161, 78, 107, 0.5); }

.reset-btn { 
  background: transparent; 
  border: 2px solid var(--gold-dim); 
  color: var(--gold-dim); 
  margin-top: 50px; position: relative; z-index: 100;
}
.reset-btn:hover { background: rgba(197, 160, 89, 0.1); }

/* --- 3. 牌阵区域 --- */
.spread-area {
  display: none; 
  position: relative; width: 100%;
  min-height: 100vh; overflow: visible; 
  flex-direction: column; align-items: center;
  padding-bottom: 100px;
}

.spread-area[style*="display: block"], .spread-area[style*="display:block"] {
  display: flex !important;
}

.spread-title {
  font-family: 'Cinzel', serif; 
  color: var(--gold-primary);
  font-size: 2rem; 
  margin-bottom: 40px; 
  z-index: 10;
  width: 100%;
  text-align: center;
}
.celtic-cross {
  position: relative; width: 1000px; height: 800px;
  flex-shrink: 0; transform-origin: top center; 
  transition: transform 0.3s ease; margin-bottom: 20px; 
}

/* --- 4. 卡牌样式系统 --- */
.tarot-card {
  position: absolute; width: 120px; height: 190px;
  background: 
    repeating-linear-gradient(45deg, rgba(255,215,0,0.05) 0px, rgba(255,215,0,0.05) 2px, transparent 2px, transparent 8px),
    linear-gradient(135deg, #2d2d44 0%, #1a1a2e 100%);
  border: 2px solid #4a4a6a; border-radius: 12px;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  cursor: pointer; user-select: none; z-index: 1;
  transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
  box-shadow: 0 5px 15px rgba(0,0,0,0.5);
  transform: translate(-50%, -50%); /* 默认居中 */
}

.tarot-card::after {
  content: ''; position: absolute;
  top: 5px; left: 5px; right: 5px; bottom: 5px;
  border: 1px solid rgba(255, 215, 0, 0.3); border-radius: 8px; pointer-events: none;
}

/* --- 修复：通用 Hover 动画 (包含已翻开的牌) --- */
.tarot-card:hover {
  /* 重点：不改变translate定位，只增加轻微的 scale 和 阴影 */
  /* 这里必须重新声明 translate(-50%, -50%) 否则会覆盖掉基础样式导致错位 */
  transform: translate(-50%, -50%) scale(1.03);
  border-color: var(--gold-primary);
  box-shadow: 0 0 20px rgba(255, 215, 0, 0.2), 0 0 10px rgba(157, 78, 221, 0.3);
  z-index: 100; /* Hover时层级最高 */
}

/* 未翻开时的额外位移 (显得轻盈) */
.tarot-card:not(.flipped):hover {
  transform: translate(-50%, -50%) translateY(-3px) scale(1.03);
}

/* 翻开状态 */
.tarot-card.flipped {
  background: #000; border-color: var(--gold-primary);
  /* 翻开后不需要 translateY 动画，保持稳定，只响应上面的通用 scale */
}

.tarot-card img { width: 100%; height: 100%; object-fit: cover; border-radius: 10px; }

/* --- 修复：横向牌 (Card 2) 逻辑 --- */
/* 当 Card 2 翻开时，容器仍然是 190x120 (横向) */
/* 图片本身是 120x190 (竖向)，我们需要旋转它并强制它适配 */

/* 1. 容器尺寸 */
.card-2 { width: 190px; height: 120px; }

/* 2. 图片适配 */
.card-2.flipped img { 
  /* 强制图片尺寸为卡牌的原始竖向尺寸 */
  width: 120px; 
  height: 190px; 
  max-width: none; /* 移除 max-width 限制 */
  
  /* 旋转 90 度 */
  transform: rotate(90deg);
  
  /* 确保旋转后的图片居中 */
  position: absolute;
  top: 50%;
  left: 50%;
  /* 因为旋转基点在中心，我们需要通过 margin 将其拉回正确位置 */
  margin-top: -95px; /* 高度的一半 */
  margin-left: -60px; /* 宽度的一半 */
}

/* 3. 逆位处理 */
.card-2.flipped.reversed img { 
  transform: rotate(270deg); 
}

/* 普通牌的逆位 */
.tarot-card.reversed img { transform: rotate(180deg); }

.card-number { font-family: 'Cinzel', serif; font-weight: bold; color: var(--gold-primary); margin-bottom: 5px; }
.card-meaning { font-size: 0.7rem; color: #aaa; text-transform: uppercase; letter-spacing: 1px; }

/* --- 5. 绝对定位坐标 (修复 Card 1 消失) --- */
/* 核心逻辑：Card 1 和 Card 2 都在中心，Card 2 横着盖在上面 */
/* Card 1 (竖): 120x190. Top: 400. Y轴范围: 305~495 */
/* Card 2 (横): 190x120. Top: 400. Y轴范围: 340~460 */
/* 结果：Card 1 的上下各 35px 会露出来，形成十字。 */

.card-1 { left: 350px; top: 400px; z-index: 10; } /* 底层 */
.card-2 { left: 350px; top: 400px; z-index: 11; } /* 上层 */

.card-3 { left: 350px; top: 180px; }
.card-4 { left: 350px; top: 620px; }
.card-5 { left: 130px; top: 400px; }
.card-6 { left: 570px; top: 400px; }
.card-7 { left: 800px; top: 730px; }
.card-8 { left: 800px; top: 510px; }
.card-9 { left: 800px; top: 290px; }
.card-10 { left: 800px; top: 70px; }

/* 装饰连线 */
.celtic-cross::before {
  content: ''; position: absolute;
  left: 350px; top: 400px; width: 440px; height: 1px;
  background: linear-gradient(90deg, transparent, rgba(255,215,0,0.15), transparent);
  transform: translate(-50%, -50%); pointer-events: none;
}
.celtic-cross::after {
  content: ''; position: absolute;
  left: 350px; top: 400px; width: 1px; height: 440px;
  background: linear-gradient(180deg, transparent, rgba(255,215,0,0.15), transparent);
  transform: translate(-50%, -50%); pointer-events: none;
}

/* --- 6. 响应式与缩放 --- */
@media (max-width: 1100px) { .celtic-cross { transform: scale(0.9); } }
@media (max-width: 850px) { .celtic-cross { transform: scale(0.7); margin-bottom: -150px; } }
@media (max-width: 600px) { 
  .celtic-cross { transform: scale(0.45); width: 1000px; margin-left: 0; margin-bottom: -350px; }
  .header h1 { font-size: 2rem; }
  .question-section, .interpretation { padding: 25px 15px; }
  .card-info { flex-direction: column; }
}
@media (max-width: 400px) { .celtic-cross { transform: scale(0.38); margin-bottom: -450px; } }

.controls-center { text-align: center; width: 100%; margin-top: 20px; padding: 20px; }

/* --- 7. 解释区域与 Markdown 优化 --- */
.interpretation {
  display: none; margin-top: 20px; text-align: left;
}
.interpretation h3 {
  font-family: 'Cinzel', serif; color: var(--gold-primary);
  font-size: 1.8rem; border-bottom: 1px solid rgba(255,255,255,0.1);
  padding-bottom: 15px; margin-bottom: 30px; text-align: center;
}

.card-info {
  display: flex; gap: 30px; margin-bottom: 30px;
  background: rgba(0,0,0,0.2); padding: 25px; border-radius: 15px;
  border: 1px solid var(--glass-border);
}

.card-preview {
  width: 140px; height: 210px; flex-shrink: 0;
  border: 2px solid var(--gold-dim); border-radius: 10px; overflow: hidden;
  background: rgba(0, 0, 0, 0.3);
}
.card-preview img { width: 100%; height: 100%; object-fit: contain; border-radius: 8px; }

.card-details h4 { font-family: 'Cinzel', serif; color: #fff; font-size: 1.8rem; margin-bottom: 10px; }
.card-position { color: var(--accent-purple); font-family: 'Cormorant Garamond', serif; font-style: italic; font-size: 1.3rem; margin-bottom: 8px; }
.card-orientation { display: inline-block; background: rgba(255,215,0,0.1); color: var(--gold-primary); padding: 4px 12px; border-radius: 12px; font-size: 0.95rem; border: 1px solid rgba(255,215,0,0.3); }

/* --- 修复：Markdown 渲染样式 --- */
.ai-interpretation {
  font-size: 1.1rem;
  line-height: 1.8;
  color: #e0e0e0;
}

/* 标题优化 */
.ai-interpretation h1, 
.ai-interpretation h2, 
.ai-interpretation h3 {
  font-family: 'Cinzel', serif;
  color: var(--gold-primary);
  margin-top: 1.5em;
  margin-bottom: 0.8em;
  border-bottom: 1px solid rgba(255, 215, 0, 0.1);
  padding-bottom: 5px;
  display: inline-block; /* 让下划线只包裹文字 */
}

.ai-interpretation h1 { font-size: 1.6rem; }
.ai-interpretation h2 { font-size: 1.4rem; }

/* 段落优化 */
.ai-interpretation p {
  margin-bottom: 1.2em;
  text-align: justify; /* 两端对齐更显质感 */
}

/* 列表优化 */
.ai-interpretation ul, 
.ai-interpretation ol {
  margin-bottom: 1.5em;
  padding-left: 1.5em;
}

.ai-interpretation li {
  margin-bottom: 0.5em;
  position: relative;
}

/* 强调文字 */
.ai-interpretation strong, 
.ai-interpretation b {
  color: var(--gold-primary);
  font-weight: 600;
  text-shadow: 0 0 5px rgba(255, 215, 0, 0.2);
}

/* 引用块优化 */
.ai-interpretation blockquote {
  border-left: 4px solid var(--accent-purple);
  background: linear-gradient(90deg, rgba(157, 78, 221, 0.1) 0%, transparent 100%);
  padding: 15px 20px;
  margin: 20px 0;
  border-radius: 0 8px 8px 0;
  color: #d0d0ff;
  font-style: italic;
  font-family: 'Cormorant Garamond', serif;
  font-size: 1.2rem;
}

/* 代码块/关键术语 */
.ai-interpretation code {
  background: rgba(255, 255, 255, 0.1);
  padding: 2px 6px;
  border-radius: 4px;
  font-family: monospace;
  color: var(--accent-purple);
}

/* 加载动画 */
.loading { display: flex; justify-content: center; align-items: center; gap: 10px; color: var(--gold-primary); padding: 20px; font-family: 'Cinzel', serif; }
.spinner { width: 24px; height: 24px; border: 2px solid transparent; border-top-color: var(--gold-primary); border-radius: 50%; animation: spin 0.8s linear infinite; }
@keyframes spin { to { transform: rotate(360deg); } }
</style>
</head>
<body>

<!-- 语言切换按钮 -->
<div class="language-toggle">
  <button class="lang-btn active" id="langZh" data-lang="zh">中文</button>
  <button class="lang-btn" id="langEn" data-lang="en">EN</button>
</div>

<div class="container">
  <div class="header">
    <h1><i class="fas fa-crystal-ball"></i> AI 塔罗牌占卜</h1>
    <p>让神秘的塔罗为你指引前路，探索内心的智慧</p>
  </div>

  <!-- 问题输入区域 -->
  <div class="question-section" id="questionSection">
    <h2><i class="fas fa-question-circle"></i> 请输入你想要占卜的问题</h2>
    <input type="text" class="question-input" id="questionInput" 
           placeholder="例如：我的感情会如何发展？我该如何做出这个重要决定？我的事业前景如何？" 
           maxlength="200">
    <br>
    <button class="start-btn" id="startBtn">
      <i class="fas fa-magic"></i> 开始占卜
    </button>
  </div>

  <!-- 牌阵区域 -->
  <div class="spread-area" id="spreadArea">
    <h2 class="spread-title">
      <i class="fas fa-plus"></i> 凯尔特十字牌阵
      <div style="font-size: 1rem; font-weight: 400; margin-top: 10px; color: var(--text-secondary);">
        点击任意卡牌查看详细解析
      </div>
    </h2>
    <div class="celtic-cross">
      <div class="tarot-card card-1" data-position="1" data-meaning="现状">
        <div class="card-number">1</div>
        <div class="card-meaning">现状</div>
      </div>
      <div class="tarot-card card-2" data-position="2" data-meaning="挑战">
        <div class="card-number">2</div>
        <div class="card-meaning">挑战</div>
      </div>
      <div class="tarot-card card-3" data-position="3" data-meaning="远因">
        <div class="card-number">3</div>
        <div class="card-meaning">远因</div>
      </div>
      <div class="tarot-card card-4" data-position="4" data-meaning="近因">
        <div class="card-number">4</div>
        <div class="card-meaning">近因</div>
      </div>
      <div class="tarot-card card-5" data-position="5" data-meaning="可能性">
        <div class="card-number">5</div>
        <div class="card-meaning">可能</div>
      </div>
      <div class="tarot-card card-6" data-position="6" data-meaning="近期">
        <div class="card-number">6</div>
        <div class="card-meaning">近期</div>
      </div>
      <div class="tarot-card card-7" data-position="7" data-meaning="你的方法">
        <div class="card-number">7</div>
        <div class="card-meaning">方法</div>
      </div>
      <div class="tarot-card card-8" data-position="8" data-meaning="外在影响">
        <div class="card-number">8</div>
        <div class="card-meaning">外在</div>
      </div>
      <div class="tarot-card card-9" data-position="9" data-meaning="希望恐惧">
        <div class="card-number">9</div>
        <div class="card-meaning">内心</div>
      </div>
      <div class="tarot-card card-10" data-position="10" data-meaning="最终结果">
        <div class="card-number">10</div>
        <div class="card-meaning">结果</div>
      </div>
    </div>
    
    <div class="controls-center">
      <button class="reset-btn" id="resetBtn">
        <i class="fas fa-redo"></i> 重新占卜
      </button>
    </div>
  </div>

  <!-- 解释区域 -->
  <div class="interpretation" id="interpretation">
    <h3><i class="fas fa-eye"></i> 牌面解析</h3>
    <div class="card-info">
      <div class="card-preview" id="cardPreview">
        <img id="cardImage" src="" alt="">
      </div>
      <div class="card-details">
        <h4 id="cardName"></h4>
        <div class="card-position" id="cardPosition"></div>
        <div class="card-orientation" id="cardOrientation"></div>
      </div>
    </div>
    <div class="ai-interpretation" id="aiInterpretation">
      <div class="loading">
        <div class="spinner"></div>
        <span>AI正在为你解读牌面...</span>
      </div>
    </div>
  </div>
</div>

<script>
let ws;
let tarotCards = [];
let currentQuestion = '';
let selectedCards = [];
let isGenerating = false;
let systemPromptSet = false;
let wsConnected = false;

// 国际化相关变量
let currentLang = 'zh'; // 默认中文
let langData = {}; // 当前语言数据

// 使用LocalStorage实现持久化缓存
const interpretationCacheKey = 'tarotInterpretationCache';

// 简化的缓存管理 - 直接使用localStorage，不需要复杂的索引
function getInterpretationFromCache(cacheKey) {
  try {
    const storageKey = `${interpretationCacheKey}_${cacheKey}`;
    const cachedContent = localStorage.getItem(storageKey);
    if (cachedContent) {
      console.log('从缓存获取内容，键:', cacheKey, '长度:', cachedContent.length);
      return cachedContent;
    }
    return null;
  } catch (e) {
    console.error('获取缓存出错:', e);
    return null;
  }
}

// 设置缓存
function setInterpretationCache(cacheKey, interpretation) {
  try {
    // 确保内容非空
    if (!interpretation || interpretation.length < 10) {
      console.error('尝试缓存空内容或内容太短');
      return false;
    }
    
    const storageKey = `${interpretationCacheKey}_${cacheKey}`;
    localStorage.setItem(storageKey, interpretation);
    
    console.log(`缓存保存成功 - 键: ${cacheKey}, 长度: ${interpretation.length}`);
    
    // 立即验证
    const verify = localStorage.getItem(storageKey);
    if (verify && verify.length > 0) {
      console.log('缓存验证成功');
      return true;
    } else {
      console.error('缓存验证失败');
      return false;
    }
  } catch (e) {
    console.error('保存缓存出错:', e);
    return false;
  }
}

// 生成稳定的缓存键 - 改进算法确保一致性
function generateCacheKey(card, position, question) {
  // 使用卡牌名称、位置、正逆位状态和问题的MD5哈希来生成稳定的键
  // 为了简化，这里使用一个简单但稳定的字符串组合
  const questionHash = question.replace(/\s+/g, '').substring(0, 20); // 去除空格，取前20个字符
  return `${card.name.replace(/\s+/g, '')}_${position}_${card.reversed ? 'R' : 'U'}_${questionHash}`;
}

// 解释选中的牌函数
function interpretCard(index) {
  if (isGenerating) {
    console.log('AI正在生成解读，请等待');
    return;
  }
  
  if (!wsConnected) {
    alert('连接已断开，请刷新页面重试');
    return;
  }
  
  const card = selectedCards[index];
  const cardElement = document.querySelectorAll('.tarot-card')[index];
  const position = parseInt(cardElement.dataset.position);
  
  console.log('解释牌面:', card.name, '位置:', position, '逆位:', card.reversed);
  
  // 修正图片路径
  const imagePath = card.image_path.replace('/cards/', 'cards/');
  
  // 显示牌面
  cardElement.classList.add('flipped');
  cardElement.innerHTML = `<img src="${imagePath}" alt="${card.name}" onerror="this.src='placeholder.jpg'">`;
  if (card.reversed) {
    cardElement.classList.add('reversed');
  }
  
  // 显示牌面信息
  document.getElementById('cardName').textContent = card.name;
  document.getElementById('cardPosition').textContent = getPositions()[position];
  document.getElementById('cardOrientation').textContent = card.reversed ? (langData.reversed || '逆位') : (langData.upright || '正位');
  
  const cardImage = document.getElementById('cardImage');
  cardImage.src = imagePath;
  cardImage.onerror = function() { this.src = 'placeholder.jpg'; };
  
  if (card.reversed) {
    cardImage.style.transform = 'rotate(180deg)';
  } else {
    cardImage.style.transform = 'none';
  }
  
  // 显示解释区域
  document.getElementById('interpretation').style.display = 'block';
  
  // 生成缓存键
  const cacheKey = generateCacheKey(card, position, currentQuestion);
  console.log('检查缓存键:', cacheKey);
  
  // 检查是否存在缓存
  const cachedContent = getInterpretationFromCache(cacheKey);
  if (cachedContent) {
    console.log('找到缓存，直接显示，长度:', cachedContent.length);
    
    // 显示缓存加载状态
    document.getElementById('aiInterpretation').innerHTML = `
      <div style="color: var(--gold-color); text-align: center; padding: 20px;">
        <i class="fas fa-history"></i> 读取缓存中...
      </div>
    `;
    
    // 滚动到解释区域
    document.getElementById('interpretation').scrollIntoView({ 
      behavior: 'smooth',
      block: 'start'
    });
    
    // 显示缓存结果
    setTimeout(() => {
      displayInterpretation(cachedContent, false);
    }, 500);
    return;
  }
  
  console.log('没有找到缓存，请求AI解析');
  
  // 没有缓存，显示加载状态并请求AI解析
  document.getElementById('aiInterpretation').innerHTML = `
    <div class="loading">
      <div class="spinner"></div>
      <span>AI正在为你解读牌面...</span>
    </div>
  `;
  
  // 滚动到解释区域
  document.getElementById('interpretation').scrollIntoView({ 
    behavior: 'smooth',
    block: 'start'
  });
  
  // 发送解释请求到AI
  requestInterpretation(card, position, cacheKey);
}

// 显示AI解释
function displayInterpretation(interpretation, shouldCache = true) {
  if (!interpretation || interpretation.length === 0) {
    console.error('解析内容为空');
    return;
  }
  
  console.log('显示AI解释，内容长度:', interpretation.length, '是否缓存:', shouldCache);
  const interpretationElement = document.getElementById('aiInterpretation');
  
  // 使用marked.js库解析markdown格式
  try {
    interpretationElement.innerHTML = marked.parse(interpretation);
    console.log('Markdown解析成功');
  } catch (e) {
    console.error('解析markdown出错:', e);
    interpretationElement.textContent = interpretation;
  }
  
  // 自动滚动页面到底部
  setTimeout(() => {
    window.scrollTo({
      top: document.body.scrollHeight,
      behavior: 'smooth'
    });
  }, 10);
  
  // 如果需要缓存且有缓存键，则保存解释到缓存
  if (shouldCache && currentRequestCacheKey && interpretation.length > 10) {
    console.log('准备保存到缓存，键:', currentRequestCacheKey);
    
    // 确保内容有效
    if (interpretation.trim().length > 0) {
      setInterpretationCache(currentRequestCacheKey, interpretation);
      
      // 直接验证localStorage中是否存储成功
      setTimeout(() => {
        const directCacheKey = `${interpretationCacheKey}_${currentRequestCacheKey}`;
        const cachedContent = localStorage.getItem(directCacheKey);
        if (cachedContent && cachedContent.length > 0) {
          console.log('直接验证缓存成功，已存储在:', directCacheKey);
          console.log('缓存内容长度:', cachedContent.length);
        } else {
          console.error('直接验证缓存失败，键:', directCacheKey);
        }
      }, 200);
    } else {
      console.error('内容为空，不进行缓存');
    }
    
    currentRequestCacheKey = null;
  }
  
  isGenerating = false;
  toggleCardClickability(true);
}

// 这段重复的WebSocket消息处理将被删除，因为已经在initWS函数中定义了相同功能


// 这个函数已在上方定义，删除此重复定义

// 清空缓存
function clearInterpretationCache() {
  try {
    // 先获取所有缓存键
    const cachedIndex = localStorage.getItem(interpretationCacheKey);
    if (cachedIndex) {
      const index = JSON.parse(cachedIndex);
      
      // 删除所有单独存储的缓存项
      for (const key in index) {
        const storageKey = `${interpretationCacheKey}_${key}`;
        localStorage.removeItem(storageKey);
      }
    }
    
    // 删除缓存索引
    localStorage.removeItem(interpretationCacheKey);
    console.log('解析结果缓存已清空');
  } catch (e) {
    console.error('清空缓存出错:', e);
  }
}

// 解析内容构建器
let interpretationBuilder = '';

// 国际化函数
function initLanguage() {
  // 从localStorage获取保存的语言设置，默认为中文
  const savedLang = localStorage.getItem('tarot_language') || 'zh';
  switchLanguage(savedLang);
}

function switchLanguage(lang) {
  currentLang = lang;
  
  // 获取语言数据
  if (lang === 'zh') {
    langData = window.zh || {};
  } else if (lang === 'en') {
    langData = window.en || {};
  }
  
  // 保存语言设置到localStorage
  localStorage.setItem('tarot_language', lang);
  
  // 更新界面
  updateUI();
  
  // 更新语言按钮状态
  updateLanguageButtons();
  
  // 更新HTML lang属性
  document.documentElement.lang = lang === 'zh' ? 'zh-CN' : 'en';
  
  console.log('切换到语言:', lang);
}

function updateUI() {
  if (!langData) return;
  
  // 更新页面标题
  document.title = langData.pageTitle || 'AI 塔罗牌占卜';
  
  // 更新头部
  const headerTitle = document.querySelector('.header h1');
  if (headerTitle) {
    headerTitle.innerHTML = `<i class="fas fa-crystal-ball"></i> ${langData.mainTitle || 'AI 塔罗牌占卜'}`;
  }
  
  const headerSubtitle = document.querySelector('.header p');
  if (headerSubtitle) {
    headerSubtitle.textContent = langData.subtitle || '让神秘的塔罗为你指引前路，探索内心的智慧';
  }
  
  // 更新问题输入区域
  const questionTitle = document.querySelector('.question-section h2');
  if (questionTitle) {
    questionTitle.innerHTML = `<i class="fas fa-question-circle"></i> ${langData.questionTitle || '请输入你想要占卜的问题'}`;
  }
  
  const questionInput = document.getElementById('questionInput');
  if (questionInput) {
    questionInput.placeholder = langData.questionPlaceholder || '例如：我的感情会如何发展？我该如何做出这个重要决定？我的事业前景如何？';
  }
  
  const startBtn = document.getElementById('startBtn');
  if (startBtn) {
    startBtn.innerHTML = `<i class="fas fa-magic"></i> ${langData.startButton || '开始占卜'}`;
  }
  
  // 更新牌阵区域
  const spreadTitle = document.querySelector('.spread-title');
  if (spreadTitle) {
    spreadTitle.innerHTML = `<i class="fas fa-plus"></i> ${langData.spreadTitle || '凯尔特十字牌阵'}
      <div style="font-size: 1rem; font-weight: 400; margin-top: 10px; color: var(--text-secondary);">
        ${langData.spreadSubtitle || '点击任意卡牌查看详细解析'}
      </div>`;
  }
  
  const resetBtn = document.getElementById('resetBtn');
  if (resetBtn) {
    resetBtn.innerHTML = `<i class="fas fa-redo"></i> ${langData.resetButton || '重新占卜'}`;
  }
  
  // 更新解释区域
  const interpretationTitle = document.querySelector('.interpretation h3');
  if (interpretationTitle) {
    interpretationTitle.innerHTML = `<i class="fas fa-eye"></i> ${langData.interpretationTitle || '牌面解析'}`;
  }
  
  // 更新卡牌含义
  updateCardMeanings();
  
  // 如果当前显示加载消息，也需要更新
  const loadingSpan = document.querySelector('.loading span');
  if (loadingSpan) {
    loadingSpan.textContent = langData.loadingMessage || 'AI正在为你解读牌面...';
  }
}

function updateCardMeanings() {
  if (!langData.cardMeanings) return;
  
  // 更新卡牌含义显示
  const cards = document.querySelectorAll('.tarot-card');
  cards.forEach((card, index) => {
    const position = index + 1;
    const meaningElement = card.querySelector('.card-meaning');
    if (meaningElement) {
      const originalMeaning = card.dataset.meaning;
      const translatedMeaning = langData.cardMeanings[originalMeaning] || originalMeaning;
      meaningElement.textContent = translatedMeaning;
    }
  });
}

function updateLanguageButtons() {
  // 移除所有按钮的active类
  document.querySelectorAll('.lang-btn').forEach(btn => {
    btn.classList.remove('active');
  });
  
  // 为当前语言按钮添加active类
  const currentBtn = document.querySelector(`[data-lang="${currentLang}"]`);
  if (currentBtn) {
    currentBtn.classList.add('active');
  }
}

// 凯尔特十字各位置含义 - 使用函数返回以支持动态语言切换
function getPositions() {
  return langData.positions || {
    1: "现状 - 你当前的状况",
    2: "挑战 - 你面临的挑战或阻碍", 
    3: "远因 - 过去的影响",
    4: "近因 - 近期的影响",
    5: "可能性 - 可能的发展",
    6: "近期 - 近期的发展",
    7: "你的方法 - 你应该采取的方法",
    8: "外在影响 - 外在环境的影响",
    9: "希望恐惧 - 你内心的希望与恐惧",
    10: "最终结果 - 最终的结果"
  };
}

// 在页面加载时检查缓存状态
function checkCacheStatus() {
  try {
    // 统计现有缓存数量
    let cacheCount = 0;
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith(interpretationCacheKey + '_')) {
        cacheCount++;
      }
    }
    console.log(`初始缓存状态: 发现 ${cacheCount} 个缓存项`);
  } catch (e) {
    console.error('检查缓存状态出错:', e);
  }
}

// 初始化WebSocket连接
function initWS() {
  console.log('正在初始化WebSocket连接...');
  const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
  ws = new WebSocket(`${proto}//${location.host}/ws`);
  
  ws.onopen = () => {
    console.log('WebSocket连接已建立');
    wsConnected = true;
    loadTarotCards();
  };
  
  ws.onerror = (error) => {
    console.error('WebSocket错误:', error);
    wsConnected = false;
  };
  
  ws.onclose = (event) => {
    console.log('WebSocket连接已断开:', event);
    wsConnected = false;
    // 3秒后重新连接
    setTimeout(initWS, 3000);
  };
  
  ws.onmessage = (e) => {
    try {
      const data = JSON.parse(e.data);
      console.log('收到WebSocket消息:', data.type);
      
      if (data.type === 'messages_update' || data.type === 'broadcast_messages') {
        const messages = data.data.messages;
        if (messages && messages.length > 0) {
          const lastMessage = messages[messages.length - 1];
          if (lastMessage.role === 'assistant') {
            // 存储完整的解释内容
            const fullContent = lastMessage.content;
            console.log('收到AI解释内容，完整长度:', fullContent.length);
            
            // 构建完整解析内容
            interpretationBuilder = fullContent;
            
            // 检查是否是最终完整解释（根据消息类型判断）
            // broadcast_messages 表示完成的响应，可以缓存
            const isCompleteResponse = data.type === 'broadcast_messages';
            
            // 显示解释内容，只有在完整响应时才缓存
            if (fullContent && fullContent.length > 10) {
              displayInterpretation(fullContent, isCompleteResponse);
              
              // 自动滚动到页面底部，确保显示最新内容
              window.scrollTo({
                top: document.body.scrollHeight,
                behavior: 'smooth'
              });
              
              // 在完整响应时输出调试信息
              if (isCompleteResponse && currentRequestCacheKey) {
                console.log('收到完整响应，将缓存结果，键:', currentRequestCacheKey);
              }
            }
          }
        }
      }
    } catch (error) {
      console.error('解析WebSocket消息出错:', error);
    }
  };
}

// 安全的WebSocket发送
function safeSend(data) {
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify(data));
    console.log('发送WebSocket消息:', data);
    return true;
  } else {
    console.warn('WebSocket未连接，无法发送消息:', data);
    return false;
  }
}

// 加载塔罗牌数据
async function loadTarotCards() {
  try {
    const response = await fetch('cards.json');
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    tarotCards = await response.json();
    console.log('塔罗牌数据加载完成，共', tarotCards.length, '张牌');
  } catch (error) {
    console.error('加载塔罗牌数据失败:', error);
    // 可以在这里添加用户友好的错误提示
  }
}

// 设置系统提示词（只设置一次）
function setSystemPrompt() {
  if (systemPromptSet || !wsConnected) {
    console.log('系统提示词已设置或WebSocket未连接');
    return;
  }
  
  const systemPrompt = `你是一位专业的塔罗牌占卜师，具有深厚的塔罗知识和直觉洞察力。请为用户提供准确、有深度且有启发性的塔罗牌解读。

请遵循以下要求：
1. 结合牌的含义、位置含义和正逆位来解读
2. 联系用户的具体问题给出针对性建议
3. 语言要神秘而富有诗意，但又要实用
4. 解读长度在150-300字之间
5. 先简述牌的基础含义，再结合位置和问题深入分析，最后给出建议

用户会发送给你牌面信息，包括牌名、牌在凯尔特十字牌阵的位置、正逆位、含义、元素等信息，以及用户的问题。请根据这些信息给出专业的塔罗牌解读。`;

  if (safeSend({
    type: 'set_system_prompt',
    data: { text: systemPrompt }
  })) {
    systemPromptSet = true;
    console.log('系统提示词设置成功');
  }
}

// 开始占卜
function startReading() {

  // 首先触发清空消息
  if (wsConnected) {
    safeSend({
      type: 'trigger_clear_message'
    });
    console.log('已发送清空非系统消息外的消息指令');
  }

  const question = document.getElementById('questionInput').value.trim();
  if (!question) {
    alert('请输入你想要占卜的问题');
    return;
  }
  
  if (!wsConnected) {
    alert('连接未就绪，请稍后再试');
    return;
  }
  
  if (!tarotCards || tarotCards.length === 0) {
    alert('塔罗牌数据未加载完成，请稍后再试');
    return;
  }
  
  currentQuestion = question;
  document.getElementById('questionSection').style.display = 'none';
  document.getElementById('spreadArea').style.display = 'block';
  
  // 添加滚动到牌阵区域的逻辑
  setTimeout(() => {
    const spreadArea = document.getElementById('spreadArea');
    const windowHeight = window.innerHeight;
    const spreadAreaHeight = spreadArea.offsetHeight;
    const targetScrollTop = spreadArea.offsetTop - (windowHeight / 2) + (spreadAreaHeight / 2);
    
    window.scrollTo({
      top: targetScrollTop,
      behavior: 'smooth'
    });
  }, 100); // 100ms延迟确保DOM更新完成后再滚动
  
  // 设置系统提示词
  setSystemPrompt();
  
  // 随机选择10张牌并设置到牌阵中
  setupSpread();
}

// 设置牌阵
function setupSpread() {
  console.log('设置牌阵，塔罗牌总数:', tarotCards.length);
  
  // 随机选择10张不重复的牌
  const shuffledCards = [...tarotCards].sort(() => Math.random() - 0.5);
  selectedCards = shuffledCards.slice(0, 10);
  
  // 为每张牌设置翻转状态（50%概率逆位）
  selectedCards = selectedCards.map(card => ({
    ...card,
    reversed: Math.random() < 0.5
  }));
  
  console.log('选择的牌:', selectedCards.map(card => `${card.name}(${card.reversed ? '逆位' : '正位'})`));
  
  // 设置卡牌点击事件
  const cardElements = document.querySelectorAll('.tarot-card');
  cardElements.forEach((cardEl, index) => {
    cardEl.onclick = () => interpretCard(index);
  });
}

// 这个函数已被上面重新定义的interpretCard函数替换，删除此重复定义

// 请求AI解释
function requestInterpretation(card, position, cacheKey) {
  if (!wsConnected || isGenerating) {
    console.log('WebSocket未连接或正在生成中');
    return;
  }
  
  isGenerating = true;
  console.log('开始请求AI解释');
  console.log('当前缓存键:', cacheKey);
  
  // 最后检查一次缓存
  const directCacheKey = `${interpretationCacheKey}_${cacheKey}`;
  const lastCheckCache = localStorage.getItem(directCacheKey);
  
  if (lastCheckCache && lastCheckCache.length > 10) {
    console.log('最后检查发现缓存存在，使用缓存，长度:', lastCheckCache.length);
    isGenerating = false;
    
    // 显示缓存加载状态
    document.getElementById('aiInterpretation').innerHTML = `
      <div style="color: var(--gold-color); text-align: center; padding: 20px;">
        <i class="fas fa-history"></i> 发现缓存，立即加载...
      </div>
    `;
    
    // 显示缓存的结果
    setTimeout(() => {
      displayInterpretation(lastCheckCache, false);
    }, 300);
    return;
  }
  
  console.log('确认无缓存，请求AI生成解读');
  
  // 重置解析内容构建器
  interpretationBuilder = '';
  
  // 在生成解读时禁用所有卡牌点击
  toggleCardClickability(false);
  
  // 构造用户输入，包含所有牌面信息
  let userInput = `请为我解读这张牌：

牌面信息：
- 牌名：${card.name}
- 位置：${getPositions()[position]}
- 方位：${card.reversed ? '逆位' : '正位'}
- 正位含义：${card.meanings.upright.join(', ')}
- 逆位含义：${card.meanings.reversed.join(', ')}
- 元素：${card.element || '无特定元素'}
- 星座：${card.sign && card.sign.length > 0 ? card.sign.join(', ') : '无特定星座'}

用户问题：${currentQuestion}

请给出专业的塔罗牌解读。`;

  if (currentLang === 'en') {
    userInput = `Please interpret this card for me:

Card information:
- Name: ${card.name}
- Position: ${getPositions()[position]}
- Orientation: ${card.reversed ? 'Reversed' : 'Upright'}
- Upright meaning: ${card.meanings.upright.join(', ')}
- Reversed meaning: ${card.meanings.reversed.join(', ')}
- Element: ${card.element || 'No specific element'}
- Constellation: ${card.sign && card.sign.length > 0 ? card.sign.join(', ') : 'No specific constellation'}

User question: ${currentQuestion}

Please provide a professional tarot card interpretation in English.`;
  }

  // 记录当前请求的缓存键，用于在收到响应时保存
  currentRequestCacheKey = cacheKey;

  // 发送用户输入
  if (!safeSend({
    type: 'set_user_input',
    data: { text: userInput }
  })) {
    isGenerating = false;
    toggleCardClickability(true);
    displayInterpretation('连接失败，请刷新页面重试。', false);
    return;
  }

  // 短暂延迟后触发发送消息
  setTimeout(() => {
    if (!safeSend({
      type: 'trigger_send_message'
    })) {
      isGenerating = false;
      toggleCardClickability(true);
      displayInterpretation('发送消息失败，请重试。', false);
    }
  }, 100);
}

// 定义全局变量用于跟踪当前请求的缓存键
let currentRequestCacheKey = null;

// 切换卡牌点击能力
function toggleCardClickability(enabled) {
  const cards = document.querySelectorAll('.tarot-card:not(.flipped)');
  cards.forEach(card => {
    if (enabled) {
      card.style.cursor = 'pointer';
      card.style.opacity = '1';
    } else {
      card.style.cursor = 'not-allowed';
      card.style.opacity = '0.5';
    }
  });
}

// 这个函数已在上方定义，删除此重复定义

// 重置占卜
function resetReading() {
  console.log('重新占卜');
  
  // 首先触发清空消息
  if (wsConnected) {
    safeSend({
      type: 'trigger_clear_message'
    });
    console.log('已发送清空消息指令');
  }
  
  // 重置UI状态
  document.getElementById('questionSection').style.display = 'block';
  document.getElementById('spreadArea').style.display = 'none';
  document.getElementById('interpretation').style.display = 'none';
  document.getElementById('questionInput').value = '';
  
  // 重置所有卡牌
  document.querySelectorAll('.tarot-card').forEach((card, index) => {
    card.classList.remove('flipped', 'reversed');
    const position = index + 1;
    const meaning = card.dataset.meaning;
    card.innerHTML = `
      <div class="card-number">${position}</div>
      <div class="card-meaning">${meaning}</div>
    `;
    card.onclick = null;
  });
  
  // 重置变量
  currentQuestion = '';
  selectedCards = [];
  systemPromptSet = false; // 重置系统提示词标志
  isGenerating = false;
  interpretationBuilder = '';
  
  // 清空解析结果缓存
  clearInterpretationCache();
  
  console.log('重置完成');
}

// 事件监听
document.addEventListener('DOMContentLoaded', () => {
  console.log('页面加载完成');
  
  // 初始化语言系统
  initLanguage();
  
  // 检查缓存状态
  checkCacheStatus();
  
  // 初始化WebSocket连接
  initWS();
  
  document.getElementById('startBtn').addEventListener('click', startReading);
  document.getElementById('resetBtn').addEventListener('click', resetReading);
  
  // 语言切换按钮事件监听
  document.getElementById('langZh').addEventListener('click', () => {
    switchLanguage('zh');
  });
  
  document.getElementById('langEn').addEventListener('click', () => {
    switchLanguage('en');
  });
  
  // 回车键开始占卜
  document.getElementById('questionInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      startReading();
    }
  });
});

// 页面卸载前关闭WebSocket连接
window.addEventListener('beforeunload', () => {
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.close();
  }
});
</script>

</body>
</html>
